[
  {
    "id": "7c0c9643-92f4-4603-984d-3a25b9bd3a28",
    "name": "Node In Layers: The Only Right Way (Document Overview)",
    "description": "Canonical, opinionated, and production-proven guide for building Node In Layers systems. Every step is real, opinionated, and explained for both humans and AI. Deviate at your own risk.\n",
    "content": "```markdown\nTo understand a real Node In Layers domain, here is the exact, production-grade implementation of the `@coding` domain. All AI comments are preserved to explain the rationale and standards for each file.\n\n> **Key Standards/AI Callouts:**\n>\n> - Always export each layer (services, features, models) as named exports.\n> - The `name` export must be unique within the system.\n> - Never use default exports for layers—this is how the loader discovers your domain.\n\n```typescript\nconst name = 'coding'\nexport { name }\nexport * as services from './services.js'\nexport * as features from './features.js'\nexport * as models from './models/index.js'\n```\n\n```\n",
    "tags": [
      "overview",
      "canonical",
      "best-practices"
    ]
  },
  {
    "id": "73cb0b07-7349-4ced-b6c8-8d35ba5a00e0",
    "name": "Node In Layers: The Only Right Way (Title & Intro)",
    "description": "The main title and introductory statement for the Node In Layers canonical guide.\n",
    "content": "```\n# Node In Layers: The Only Right Way\n\n**This is the canonical, must-follow guide for building Node In Layers systems. Every step is real, opinionated, and explained for both humans and AI. Deviate at your own risk.**\n```\n",
    "tags": [
      "overview",
      "canonical",
      "best-practices"
    ]
  },
  {
    "id": "0b6d5650-c0b6-468a-924d-ffcc60df7b3c",
    "name": "How to Create a New Domain (Toolkit Scaffold)",
    "description": "Use the official toolkit to create a new domain. This ensures correct structure and discoverability.\n",
    "content": "```\n```sh\nnpx @node-in-layers/toolkit create-app coding\n```\n\n/coding\nindex.ts\nservices.ts\nfeatures.ts\ntypes.ts\n/models\nindex.ts\n```\n```\n",
    "tags": [
      "domains",
      "toolkit",
      "best-practices"
    ]
  },
  {
    "id": "81fdec37-1d24-4784-ba07-ea463bb31265",
    "name": "index.ts — Domain Entry Point",
    "description": "The entry point for a Node In Layers domain. Exports the domain's layers and unique name for system discovery.\n",
    "content": "```markdown\nTo understand a real Node In Layers domain, here is the exact, production-grade implementation of the `@coding` domain. All AI comments are preserved to explain the rationale and standards for each file.\n\n> **Key Standards/AI Callouts:**\n>\n> - Always export each layer (services, features, models) as named exports.\n> - The `name` export must be unique within the system.\n> - Never use default exports for layers—this is how the loader discovers your domain.\n\n```typescript\nconst name = 'coding'\n\nexport { name }\nexport * as services from './services.js'\nexport * as features from './features.js'\nexport * as models from './models/index.js'\n```\n```\n",
    "tags": [
      "domains",
      "architecture",
      "best-practices"
    ]
  },
  {
    "id": "7fc7f7b4-48b7-4667-a4bc-d96a80fde61f",
    "name": "services.ts — Services Layer",
    "description": "This file defines the services layer for the domain. Services connect to external resources (file systems, databases, APIs) and are always implemented as a closure factory. This pattern ensures context and configuration are available to every service.\n",
    "content": "```\n### 1.2. `services.ts` — Services Layer\n\n**Description:**\nThis file defines the services layer for the domain. Services connect to external resources (file systems, databases, APIs) and are always implemented as a closure factory. This pattern ensures context and configuration are available to every service.\n\n> **Key Standards/AI Callouts:**\n>\n> - Import order: node libraries, third-party libraries, then local libraries.\n> - Always use a named export for the `create` function.\n> - Use the context logger for all logging; always pass `crossLayerProps` for traceability.\n> - Never put business logic here—services are for external connections only.\n\n```typescript\n// AI: We should put node libraries at the top.\nimport fs from 'node:fs'\nimport path from 'node:path'\n// AI: We should then put third party libraries next.\nimport { Config, CrossLayerProps, ServicesContext } from '@node-in-layers/core'\n// AI: Then put our local libraries after that.\nimport { CodingKnowledgeLibraries, CodingServices } from './types.js'\n\n// AI: If we need to use other services, we would add it to this context after config. Then we can do. context.services.otherService.someFunction()\n// AI: Every layer in a system has a create(context) function that is exported. NEVER as a default export. This is how the system knows how to load it.\n/**\n* Create a coding service object.\n* @param context\n* @returns\n*/\nexport const create = (context: ServicesContext<Config>): CodingServices => {\n  const readCodeDescriptionFile = async (\n    codingLibrary: CodingKnowledgeLibraries,\n    crossLayerProps?: CrossLayerProps\n  ) => {\n    // AI: If you want to log messages within a function use this function. Also pass the crossLayerProps so that logging flows through.\n    const log = context.log.getInnerLogger(\n      'readCodeDescriptionFile',\n      crossLayerProps\n    )\n    const filePath = path.join(\n      __dirname,\n      './libs/templates',\n      `${codingLibrary}.md`\n    )\n    // AI: Use trace for logging within services.\n    log.trace('Reading Code Library File', { filePath })\n    const file = fs.readFileSync(filePath, 'utf8')\n    log.trace('Reading Code Library File', { filePath })\n    return file\n  }\n\n  return {\n    readCodeDescriptionFile,\n  }\n}\n\n```\n```\n",
    "tags": [
      "domains",
      "services",
      "architecture",
      "best-practices"
    ]
  },
  {
    "id": "21229efb-9d95-48b1-8ce7-0922837c9919",
    "name": "features.ts — Features Layer",
    "description": "This file defines the features layer for the domain. Features integrate services and implement business logic. They are always implemented as a closure factory and should never connect to external resources directly.\n",
    "content": "```\n### 1.3. `features.ts` — Features Layer\n\n**Description:**\nThis file defines the features layer for the domain. Features integrate services and implement business logic. They are always implemented as a closure factory and should never connect to external resources directly.\n\n> **Key Standards/AI Callouts:**\n>\n> - Always use the context logger for all logging; pass `crossLayerProps` for traceability.\n> - Use `error` for critical failures, `debug` for internal feature logic.\n> - Features should only call services, never connect to external resources directly.\n> - Return pure data structures—never mutate context or state.\n\n```typescript\nimport { randomUUID } from 'node:crypto'\nimport {\n  Config,\n  CrossLayerProps,\n  FeaturesContext,\n} from '@node-in-layers/core'\nimport {\n  CodingServicesLayer,\n  CodingFeaturesLayer,\n  CodingFeatures,\n  CodingKnowledgeLibraries,\n} from './types.js'\n\nexport const create = (\n  // NOTE: We are going to use the coding services object, so we need to add the layer here to the context which is specific to features.\n  context: FeaturesContext<Config, CodingServicesLayer>\n): CodingFeatures => {\n  const _availableLibraries = [CodingKnowledgeLibraries.nodeInLayers]\n\n  const listAvailableCodeKnowledgeBases = async (\n    crossLayerProps?: CrossLayerProps\n  ) => {\n    return Promise.resolve(_availableLibraries)\n  }\n\n  // AI: All of these inputs are automatically logged when this function is executed.\n  const getCodeLibraryKnowledgeBase = async (\n    codingLibrary: CodingKnowledgeLibraries,\n    tags?: readonly string[],\n    crossLayerProps?: CrossLayerProps\n  ) => {\n    const log = context.log.getInnerLogger(\n      'getCodeLibraryKnowledgeBase',\n      crossLayerProps\n    )\n    if (_availableLibraries.includes(codingLibrary) === false) {\n      // AI: If you have an error that ends execution, use error.\n      log.error(`Coding library ${codingLibrary} not found`)\n      throw new Error(`Coding library ${codingLibrary} not found`)\n    }\n\n    // AI: Inside of features, use debug for logging.\n    // AI: Btw this log message is not needed. Its just for show.\n    log.debug('Reading code library', { codingLibrary })\n    // AI: ALWAYS pass the crossLayerProps to other features/services or any other layer call.\n    const content = await context.services.coding.readCodeDescriptionFile(\n      codingLibrary,\n      crossLayerProps\n    )\n    return [\n      {\n        id: randomUUID(),\n        library: codingLibrary,\n        title: `Code Library: ${codingLibrary} details`,\n        details: content,\n        tags: ['typescript', 'nodejs', codingLibrary, 'how-to', 'examples'],\n        lastModified: new Date(),\n        createdAt: new Date(),\n      },\n    ]\n  }\n\n  return {\n    listAvailableCodeKnowledgeBases,\n    getCodeLibraryKnowledgeBase,\n  }\n}\n```\n\n```\n",
    "tags": [
      "features",
      "typescript",
      "nodejs",
      "layer",
      "business-logic"
    ]
  },
  {
    "id": "21d72502-e037-45ba-9c63-5c32bd686f88",
    "name": "types.ts — Types and Contracts",
    "description": "This file defines all types, enums, and contracts for the domain. Types are always exported at the bottom. AI comments explain the use of Readonly, LayerFunction, and export conventions.\n",
    "content": "```\n\n### 1.4. `types.ts` — Types and Contracts\n\n**Description:**\nThis file defines all types, enums, and contracts for the domain. Types are always exported at the bottom. AI comments explain the use of Readonly, LayerFunction, and export conventions.\n\n> **Key Standards/AI Callouts:**\n>\n> - Use `Readonly` for all types to enforce immutability.\n> - Use `LayerFunction` to ensure all functions accept `crossLayerProps` for traceability.\n> - Export all types at the bottom of the file for discoverability.\n\n```typescript\nimport { LayerFunction } from '@node-in-layers/core'\n\nexport enum CodingKnowledgeLibraries {\n  nodeInLayers = 'node-in-layers',\n  functionalModels = 'functional-models',\n  nodeInLayersData = 'node-in-layers-data',\n  nodeInLayersExpress = 'node-in-layers-express',\n}\n\n// AI: This is a type, that we will later create a model for, so we can save in a database.\n// AI: Notice that we are using Readonly<{}> for our types.\nexport type CodingKnowledgeBaseEntry = Readonly<{\n  id: string\n  library: CodingKnowledgeLibraries\n  title: string\n  details: string\n  tags: string[]\n  lastModified: Date\n  createdAt: Date\n}>\n\n// AI: \"DomainServices\" is the type that is produced by a services factory\nexport type CodingServices = Readonly<{\n  // AI: If you use the LayerFunction<> type, it automatically adds the CrossLayerProps to the end of the function. This is needed for tracing throughout the system.\n  readCodeDescriptionFile: LayerFunction<\n    (codingLibrary: CodingKnowledgeLibraries) => Promise<string>\n  >\n}>\n\n// AI: \"DomainServicesLayer\" is the type that another service/feature uses to explicitly say it uses this service\nexport type CodingServicesLayer = Readonly<{\n  coding: CodingServices\n}>\n\n// AI: \"DomainFeatures\" is the type that is produced by a features factory\nexport type CodingFeatures = Readonly<{\n  // I want to provide the AI the ability to see what code libraries are available to it\n  listAvailableCodeKnowledgeBases: LayerFunction<\n    () => Promise<CodingKnowledgeLibraries[]>\n  >\n  // I know that the AI will need the ability to get the specific entries for a library\n  getCodeLibraryKnowledgeBase: LayerFunction<\n    (\n      codingLibrary: CodingKnowledgeLibraries,\n      tags?: readonly string[]\n    ) => Promise<CodingKnowledgeBaseEntry[]>\n  >\n}>\n\n// AI: \"DomainFeaturesLayer\" is the type that another service/feature uses to explicitly say it uses this feature\nexport type CodingFeaturesLayer = Readonly<{\n  coding: CodingFeatures\n}>\n\n```\n\n```\n",
    "tags": [
      "types",
      "contracts",
      "typescript",
      "nodejs",
      "layer"
    ]
  },
  {
    "id": "9d205a10-b48e-44c6-9dc4-2c18507386ec",
    "name": "Model Exports and Persistent Model for Coding Knowledge Base",
    "description": "This entry documents the canonical approach for exporting models and defining persistent models in a Node In Layers domain. All models must be exported with their plural name for system discoverability. Persistent models use property creators from `functional-models` to enforce type safety and validation. The `create` function and naming conventions are required for automatic model loading.\n",
    "content": "### 1.5. `models/index.ts` — Model Exports\n**Description:**\nThis file exports all models for the domain. Each model must be exported with its plural name for system discoverability.\n\n> **Key Standards/AI Callouts:**\n> - Always export each model with its plural name.\n> - This pattern ensures all models are discoverable and loadable by the system.\n\n```typescript\n// We have to export each and every model with the plural name of the model.\nexport * as CodingKnowledgeBaseEntries from './CodingKnowledgeBaseEntries.js'\n```\n\n### 1.6. `models/CodingKnowledgeBaseEntries.ts` — Persistent Model\n\n**Description:**\nThis file defines the persistent model for knowledge base entries. It uses property creators from `functional-models` to enforce type safety and validation. The `create` function and naming conventions are required by Node In Layers for automatic model loading.\n\n> **Key Standards/AI Callouts:**\n>\n> - Always use property creators for each field to enforce type safety and validation.\n> - The `create` function must be named and exported for system loading.\n> - Use plural and singular names for models to avoid naming clashes.\n\n```typescript\nimport {\n  TextProperty,\n  DatetimeProperty,\n  PrimaryKeyUuidProperty,\n  ArrayProperty,\n} from 'functional-models'\nimport { ModelProps } from '@node-in-layers/core'\nimport { CodingKnowledgeBaseEntry, CodingKnowledgeLibraries } from '../types.js'\n\n/**\n * Database Model for Coding Knowledge Base Entries\n * This create function is required to be called create() so that the system can load it automatically.\n * NOTE: This model does not have any foreign keys.\n * You have to use the fetcher and getModel functions to link to other models. I have them just so you can see them.\n */\nexport const create = ({ Model, fetcher, getModel }: ModelProps) => {\n  return Model<CodingKnowledgeBaseEntry>({\n    // This is a required field.\n    pluralName: 'CodingKnowledgeBaseEntries',\n    // (Optional): But its useful to force the correct creation of a singular name. It does do it automatically behind the scenes most of the time.\n    singularName: 'CodingKnowledgeBaseEntry',\n    // The namespace should be at least the domain name, but in some cases you may have a namespace+domain if you are worried about clashes\n    namespace: 'coding',\n    // NOTE: This is not necessary if we use the value id. I put it here so you can see it.\n    primaryKeyName: 'id',\n    // Each of the type's properties are defined here. There is a whole library of properties in the functional-models library.\n    properties: {\n      // This creates a uuid automatically for the id.\n      id: PrimaryKeyUuidProperty(),\n      library: TextProperty({\n        required: true,\n        choices: Object.values(CodingKnowledgeLibraries),\n      }),\n      title: TextProperty({ required: true }),\n      details: TextProperty({ required: true }),\n      tags: ArrayProperty<string>(),\n      lastModified: DatetimeProperty({ autoNow: true }),\n      createdAt: DatetimeProperty({ autoNow: true }),\n    },\n  })\n}\n\n```\n",
    "tags": [
      "models",
      "exports",
      "persistence",
      "best-practices"
    ]
  },
  {
    "id": "9707d819-ac03-4f82-87a7-0750d95a1530",
    "name": "Minimal Real-World config.base.mts Example",
    "description": "This entry provides a real, production-ready minimal configuration example for Node In Layers systems. Use this as your starting point for any Node In Layers system. It demonstrates how to organize domains, layers, logging, databases, and environment-safe configuration.\n",
    "content": "\n### 2.1. Minimal (Real-World) `config.base.mts` Example\n\nThis is a real, production-ready minimal config. Use this as your starting point for any Node In Layers system.\n\n```typescript\n// AI:\nimport { CoreNamespace, LogFormat } from '@node-in-layers/core'\n// AI: We should only use this if we are dealing with a backend system.\nimport { DataNamespace } from '@node-in-layers/data/index.js'\n// AI: We should only use RestApi if we have an express server.\nimport { RestApiNamespace } from '@node-in-layers/rest-api/index.js'\n\nimport { createCustomLogger } from '@deep-helix/backend-sdk'\nimport { SystemConfig } from './src/types'\nimport { LogLevelNames } from '@node-in-layers/core'\nimport { SimpleServerConfig } from '@l4t/mcp-ai'\n\nconst core = {\n  // AI: The domains are loaded here in order from top to bottom.\n  apps: await Promise.all([\n    // AI: Only need if we use data.\n    import(`@node-in-layers/data/index.js`),\n    import(`@node-in-layers/rest-api/express/index.js`),\n    // AI: We created some helpful logging functionalities.\n    import(`@deep-helix/backend-sdk/dist/logging/index.js`),\n    // AI: This is just an example app\n    import(`./dist/coding/index.js`),\n    import(`./dist/mcp-server/index.js`),\n    // AI: This is just an example app for an api express server.\n    import(`./dist/api/index.js`),\n  ]),\n  // AI: The layers are loaded from left to right, except when its an array. That is a composite layer.\n  layerOrder: ['services', 'features', ['entries', 'express']],\n  logging: {\n    logLevel: LogLevelNames.trace,\n    logFormat: LogFormat.json,\n    customLogger: createCustomLogger(),\n  },\n  // AI: This sets the default model factory for database backends..\n  modelFactory: '@node-in-layers/data',\n  // AI: This should probably always be true. It automatically creates CRUD operations for all models.\n  modelCruds: true,\n  // AI: This is an example of creating multi-database systems, where for this situation the logging app uses a different database than the main app, note \"logDatabase\"\n  customModelFactory: {\n    // AI: Domain\n    ['logging']: {\n      // AI: The model's name: ['namespace', 'databaseNameListedBelow']\n      LogMessages: ['@node-in-layers/data', 'logDatabase'],\n    },\n  },\n}\n\n// AI: This is for @node-in-layers/data.\nconst data = {\n  databases: {\n    default: {\n      datastoreType: 'memory', // AI: mongo, postgres, etc.\n    },\n    // AI: Multi-database configuration\n    logDatabase: {\n      datastoreType: 'memory',\n    },\n  },\n}\n\nconst logging = {\n  colorized: false,\n  databaseLogging: false,\n  consoleLogging: true,\n}\n\nconst express = {\n  port: 3000,\n  urlPrefix: '/api/v1/',\n  logging: {\n    requestLogLevel: LogLevelNames.info,\n    responseLogLevel: LogLevelNames.info,\n  },\n  jsonBodySizeLimitInMb: 10,\n  encodedBodySizeLimitInMb: 10,\n}\n\nconst mcpServer: Omit<SimpleServerConfig, 'tools'> = {\n  name: 'my-mcp-server',\n  version: '1.0.0',\n  server: {\n    connection: {\n      type: 'cli',\n    },\n  },\n}\n\n// AI: Actually create the config as a default exported function\nexport default (): SystemConfig => ({\n  // AI: Override this.\n  environment: 'base',\n  // AI: The name of our system.\n  systemName: 'praxis-sphere/backend',\n  [CoreNamespace.root]: core,\n  [DataNamespace.root]: data,\n  [RestApiNamespace.express]: express,\n  logging,\n  mcpServer,\n})\n```\n\n**AI CALLOUT:** Real systems require detailed config for logging, databases, APIs, and more. Use this as your reference for production-grade systems. Always keep config organized, DRY, and environment-safe.\n",
    "tags": [
      "config",
      "base",
      "best-practices"
    ]
  },
  {
    "id": "97c2d711-7bed-4426-b270-c81af4ed58e8",
    "name": "Environment-Specific Config Inheritance and Overrides",
    "description": "This entry describes the canonical pattern for environment-specific configuration in Node In Layers systems. Always clone and merge the base config for environment overrides. This prevents accidental mutation, keeps your config DRY, and makes it easy to add or change only what you need for each environment. Never put secrets or credentials in committed config files.\n",
    "content": "\n### 2.2. Inheritance/Overrides\n\nFor environment-specific config, use a robust pattern that clones and merges the base config. This ensures you never mutate the base config and can safely override only what you need.\n\n```typescript\n// config.dev.mts\nimport merge from 'lodash/merge.js'\nimport cloneDeep from 'lodash/cloneDeep.js'\nimport { DataNamespace } from '@node-in-layers/data/index.js'\nimport * as config from './config.base.mts'\nimport { SystemConfig } from './src/types'\n\nexport default (): SystemConfig => {\n  const instance = config.default()\n  const cloned = cloneDeep(instance)\n  return merge(cloned, {\n    environment: 'dev',\n    [DataNamespace.root]: {\n      databases: {\n        default: {\n          datastoreType: 'mongo',\n          host: 'localhost',\n          port: 27017,\n        },\n        logDatabase: {\n          // Example: override or add dev-specific database config here\n        },\n      },\n    },\n    logging: {\n      colorized: true,\n      databaseLogging: true,\n    },\n  })\n}\n```\n\n> **AI CALLOUT:** Always clone and merge the base config for environment overrides. This pattern prevents accidental mutation, keeps your config DRY, and makes it easy to add or change only what you need for each environment. Never put secrets or credentials in committed config files.\n",
    "tags": [
      "config",
      "inheritance",
      "overrides",
      "best-practices"
    ]
  },
  {
    "id": "e1c6daad-2e78-48ab-a98a-adc8318cd293",
    "name": "Using loadSystem with Real Config",
    "description": "Advanced usage: shows how to bootstrap a Node In Layers system using the `loadSystem` function with an explicit config object. This is only needed when you want to override the automatic config loading (e.g., tests, multiple environments at once, frontends). The normal approach is to pass only `environment` and let the framework load `config.<env>.mjs` for you.\n",
    "content": "### 3.1. Using `loadSystem` with an Explicit Config (Advanced)\n\nMost of the time you should call `loadSystem` with **only** an `environment`, and let Node In Layers load your config files (e.g., `config.base.mjs`, `config.dev.mjs`) automatically.\n\nFor advanced scenarios—such as running two environments side by side, custom unit tests, or special frontend tooling—you can pass an explicit config object:\n\n```typescript\n// src/main.ts\nimport * as config from '../config.base.mjs'\nimport { loadSystem } from '@node-in-layers/core'\n\nconst system = await loadSystem({\n  environment: 'prod',\n  config: config.default(),\n})\n```\n\n> **AI CALLOUT:** Only pass a `config` object when you deliberately need to override automatic config loading (tests, multi-env, frontend, etc.). The normal approach is simply `await loadSystem({ environment: 'dev' })`.\n",
    "tags": [
      "system",
      "bootstrap",
      "config",
      "best-practices"
    ]
  },
  {
    "id": "49487af8-6b6a-4fb7-b1f7-9b1358eef006",
    "name": "What Gets Wired Up Automatically by loadSystem",
    "description": "This entry lists everything that is automatically wired up by the `loadSystem` function in Node In Layers. This automation prevents misconfiguration and reduces boilerplate. Always use the system loader. If you skip this, you will break traceability, logging, and system conventions.\n",
    "content": "### 3.2. What Gets Wired Up Automatically\n\n- All domains and their layers (models, services, features, entries)\n- Context propagation (config, loggers, crossLayerProps)\n- Logging setup for all layers\n- Model factories and CRUDs if enabled\n\n**AI CALLOUT:** This automation prevents misconfiguration and reduces boilerplate. Always use the system loader. If you skip this, you will break traceability, logging, and system conventions.\n",
    "tags": [
      "system",
      "automation",
      "wiring",
      "best-practices"
    ]
  },
  {
    "id": "c366c193-223e-4a0e-9a72-6f4c4f1b9f94",
    "name": "Minimal CLI Entry Example",
    "description": "This entry provides a minimal, real-world example of a CLI entry file for Node In Layers systems. Entries are the only place you should handle CLI args, environment, or direct user interaction. Keep them thin—just grab args, call a feature, and log output. Never put business logic in entries. They should only handle input/output and call features. This keeps your system testable and maintainable. Always use `console.info` for meaningful outputs, and use the logger for internal details.\n",
    "content": "### Entry/Bin Minimal CLI Entry Example\n\nEntries are the only place you should handle CLI args, environment, or direct user interaction. Keep them thin—just grab args, call a feature, and log output. Here is a real example using the normal `environment`-only pattern:\n\n```typescript\n// bin/coding.ts\n#!/usr/bin/env tsx\nimport { loadSystem } from '@node-in-layers/core'\n\nconst main = async () => {\n  const system = await loadSystem({\n    environment: 'dev',\n  })\n  // Example: Call a feature and print the result\n  const result = await system.features.coding.getCodeLibraryKnowledgeBase('node-in-layers')\n  console.info(JSON.stringify(result, null, 2))\n}\n\nmain()\n```\n\n> **AI CALLOUT:** Never put business logic in entries. They should only handle input/output and call features. This keeps your system testable and maintainable. Always use `console.info` for meaningful outputs, and use the logger for internal details.\n",
    "tags": [
      "entries",
      "cli",
      "best-practices"
    ]
  },
  {
    "id": "03a2732c-408a-4332-8fbe-9089c93ce9b5",
    "name": "Advanced CLI Entry Example",
    "description": "This entry provides a real, production-grade CLI entry file for a Node In Layers system. It demonstrates argument parsing, system loading, feature invocation, and robust error handling. Use a shebang and `tsx` for TypeScript executables. Use a main function and check for CLI invocation with `es-main`. Parse arguments with a library (e.g., `argparse`) for clarity and safety. Load the system using the correct config/environment. Call features only—never put business logic in the entry. Use `console.info`/`console.error` for user-facing output; handle errors and exit codes explicitly.\n",
    "content": "### 4.2. Real-World Example: Advanced CLI Entry\n\n**Description:**\nThis is a real, production-grade CLI entry file for a YouTube transcription process. It demonstrates argument parsing, system loading, feature invocation, and robust error handling.\n\n> **Key Standards/AI Callouts:**\n>\n> - Use a shebang and `tsx` for TypeScript executables.\n> - Use a main function and check for CLI invocation with `es-main`.\n> - Parse arguments with a library (e.g., `argparse`) for clarity and safety.\n> - Load the system using the correct config/environment.\n> - Call features only—never put business logic in the entry.\n> - Use `console.info`/`console.error` for user-facing output; handle errors and exit codes explicitly.\n\n```typescript\n#!/usr/bin/env tsx\n\nimport esMain from 'es-main'\nimport { ArgumentParser } from 'argparse'\nimport * as core from '@node-in-layers/core'\nimport { SystemConfig } from '../src/types.js'\nimport { System } from '../src/system/types.js'\n\n// AI: Use argparse.\nconst _parseArguments = () => {\n  const parser = new ArgumentParser({\n    description: 'Executes YouTube transcription process for a given job ID.',\n  })\n  parser.add_argument('environment', {\n    help: 'The environment for the service.',\n  })\n  parser.add_argument('jobId', {\n    help: 'The ID of the transcription job to process.',\n  })\n  return parser.parse_args()\n}\n\nconst main = async () => {\n  const args = _parseArguments()\n\n  console.info(`Starting YouTube transcription process for job: ${args.jobId}`)\n\n  // AI: Load the system, and cast it as a system object, which shows the types of the entire system.\n  const context = (await core.loadSystem<SystemConfig>({\n    environment: args.environment,\n  })) as unknown as System\n\n  try {\n    // AI: This runs a feature.\n    await context.features.pipelines.executeYoutubeTranscription(args.jobId)\n\n    console.info(\n      `YouTube transcription completed successfully for job: ${args.jobId}`\n    )\n  } catch (error) {\n    console.error('Error executing YouTube transcription:', error)\n    process.exit(1)\n  } finally {\n    // AI: Some databases will hold a connection open.\n    context.services['@node-in-layers/data'].cleanup()\n  }\n}\n\nif (esMain(import.meta)) {\n  main()\n}\n```\n",
    "tags": [
      "entries",
      "cli",
      "advanced",
      "best-practices"
    ]
  },
  {
    "id": "otel-setup-config-base",
    "name": "How to Enable OpenTelemetry in a Node In Layers System",
    "description": "Step-by-step instructions for wiring OpenTelemetry into a Node In Layers system using only configuration. You bring the OTel SDK/exporters; Node In Layers forwards logs, spans, and metrics based on config. This is a concise version of the README's OpenTelemetry section.\n",
    "content": "### Enabling OpenTelemetry via `config.base.mts`\n\nNode In Layers can forward logs, spans, and metrics to OpenTelemetry without you touching your domain code. You bring the OTel SDK and exporters; the framework forwards data based on `logging.otel` and `LogFormat.otel`.\n\n1. **Install OTel APIs (in your app)**\n\n```bash\nnpm install @opentelemetry/api @opentelemetry/api-logs\n```\n\nYou can use any OTel SDK/setup (NodeSDK, manual providers, auto-instrumentation, etc.) as long as global providers are registered.\n\n2. **Configure core logging with OTel enabled**\n\n```typescript\n// config.base.mts\nimport { CoreNamespace, LogFormat, LogLevelNames } from '@node-in-layers/core'\n\nexport default () => ({\n  systemName: 'your-system-name',\n  environment: 'base',\n  [CoreNamespace.root]: {\n    logging: {\n      logLevel: LogLevelNames.info,\n      // Send logs both to console (JSON) and to OpenTelemetry\n      logFormat: [LogFormat.json, LogFormat.otel],\n      // Optional: cap extra data size; large objects are truncated by default\n      maxLogSizeInCharacters: 50_000,\n      // Configure OpenTelemetry integration\n      otel: {\n        serviceName: 'your-system-name',\n        version: '1.0.0',\n        // Enable OTel logs (used by LogFormat.otel)\n        logs: { enabled: true },\n        // Optional: spans for wrapped layer functions\n        trace: { enabled: true },\n        // Optional: metrics for wrapped layer functions\n        metrics: { enabled: true },\n      },\n    },\n    layerOrder: ['services', 'features', 'entries'],\n    apps: [], // your apps here\n  },\n})\n```\n\n3. **Use `loadSystem` as normal (environment-only)**\n\n```typescript\nimport { loadSystem } from '@node-in-layers/core'\n\nconst system = await loadSystem({\n  environment: 'prod',\n})\n```\n\nAs long as global OTel providers are registered in your process, Node In Layers will:\n\n- Forward framework logs to the OTel Logs API when `LogFormat.otel` is configured.\n- Emit spans and metrics for wrapped layer functions when `logging.otel.trace`/`logging.otel.metrics` are enabled.\n",
    "tags": [
      "config",
      "otel",
      "logging",
      "best-practices"
    ]
  },
  {
    "id": "otel-optional-services-usage",
    "name": "Optional OpenTelemetry Services in @node-in-layers/core",
    "description": "Overview of the optional OpenTelemetry services made available by @node-in-layers/core (trace, metrics, logs, and runWithTraceAndMetrics), plus examples of calling them from a services or features layer using the correct context.services[CoreNamespace.otel] syntax.\n",
    "content": "### Optional OpenTelemetry Services (Trace, Metrics, Logs)\n\nWhen `logging.otel` is configured, Node In Layers exposes an optional OTel services domain at `CoreNamespace.otel` (`'@node-in-layers/core/otel'`). You can use this from services or features for advanced tracing/metrics/logs in addition to the automatic wrapping the framework does.\n\n```typescript\nimport { CoreNamespace, FeaturesContext, Config } from '@node-in-layers/core'\n\nexport const create = (context: FeaturesContext<Config, any, any>) => {\n  const runImportantStep = async () => {\n    const otel = context.services[CoreNamespace.otel]\n\n    // --- Traces ---\n    const span = otel.trace.startSpan('important-step', {\n      attributes: { component: 'my-domain', feature: 'runImportantStep' },\n    })\n\n    try {\n      // Do your work here\n      const activeSpan = otel.trace.getActiveSpan()\n      if (activeSpan) {\n        activeSpan.setAttribute('hasActiveSpan', true)\n      }\n    } finally {\n      span.end()\n    }\n  }\n\n  return { runImportantStep }\n}\n```\n\nYou can also use metrics helpers for custom timers and counters:\n\n```typescript\nimport { CoreNamespace, ServicesContext, Config } from '@node-in-layers/core'\n\nexport const create = (context: ServicesContext<Config>) => {\n  const recordBackgroundJobDuration = (durationMs: number) => {\n    const otel = context.services[CoreNamespace.otel]\n    otel.metrics.recordDuration('background.job.duration', durationMs, {\n      component: 'jobs',\n      jobType: 'my-job',\n    })\n    otel.metrics.incrementCounter('background.job.completed', 1, {\n      component: 'jobs',\n      jobType: 'my-job',\n    })\n  }\n\n  const requestHistogram = context.services[CoreNamespace.otel].metrics.createHistogram(\n    'http.request.duration',\n    { unit: 'ms' },\n  )\n\n  const countRequests = context.services[CoreNamespace.otel].metrics.createCounter(\n    'http.request.count',\n  )\n\n  const trackHttpRequest = (durationMs: number, path: string) => {\n    requestHistogram.record(durationMs, { path })\n    countRequests.add(1, { path })\n  }\n\n  const emitStructuredLog = () => {\n    const otel = context.services[CoreNamespace.otel]\n    otel.logs.emit({\n      body: 'Important business event',\n      attributes: { component: 'my-domain', event: 'business-event' },\n    })\n  }\n\n  const logLargePayloadExample = async () => {\n    const log = context.log.getInnerLogger('logLargePayloadExample')\n    const bigPayload = { /* huge object here */ }\n\n    // This will be truncated according to maxLogSizeInCharacters\n    await log.info('Large payload (truncated)', { bigPayload })\n\n    // If you really want to log a giant object that would normally be truncated, do this:\n    await log.info('Large payload (full)', { bigPayload }, { ignoreSizeLimit: true })\n  }\n\n  return {\n    recordBackgroundJobDuration,\n    trackHttpRequest,\n    emitStructuredLog,\n    logLargePayloadExample,\n  }\n}\n```\n\n> **AI CALLOUT:** OpenTelemetry integration is entirely optional and driven by config. If `logging.otel` is not set, `CoreNamespace.otel` services will effectively no-op. Use these helpers when you need explicit spans/metrics/logs in addition to the framework's automatic wrapping.\n",
    "tags": [
      "otel",
      "services",
      "logging",
      "metrics",
      "tracing"
    ]
  },
  {
    "id": "15b68d0d-9f62-420c-97a4-c7a1ca4c1b7b",
    "name": "Deep Dives and AI Callouts",
    "description": "This entry summarizes the most important AI callouts and common pitfalls for Node In Layers systems. At the end of each section, review the AI callouts and rationale. Common pitfalls include: not using the toolkit for domain creation, committing secrets or environment-specific config, manually wiring up layers instead of using `loadSystem`, putting business logic in entries, not using function export for config, and not using the correct namespace keys. If you are an AI, always check the knowledge base first, follow this guide exactly, and map code to layers even if the repo uses different terms. Every deviation increases the risk of subtle bugs and system breakage. This document is your source of truth for Node In Layers systems.\n",
    "content": "## 5. Deep Dives and AI Callouts\n\nAt the end of each section, review the AI callouts and rationale. Common pitfalls include:\n\n- Not using the toolkit for domain creation\n- Committing secrets or environment-specific config\n- Manually wiring up layers instead of using `loadSystem`\n- Putting business logic in entries\n- Not using function export for config\n- Not using the correct namespace keys\n\n**AI CALLOUT:** If you are an AI, always check the knowledge base first, follow this guide exactly, and map code to layers even if the repo uses different terms. Every deviation increases the risk of subtle bugs and system breakage. This document is your source of truth for Node In Layers systems.\n",
    "tags": [
      "ai",
      "callouts",
      "pitfalls",
      "best-practices"
    ]
  },
  {
    "id": "9e2cd198-cf32-45d3-8bb9-b9773cf4e452",
    "name": "All Exported Types in @node-in-layers/core",
    "description": "Key types exported from @node-in-layers/core, grouped by purpose. This is a curated subset focused on config, logging (including OpenTelemetry), layers, and model CRUDs.\n",
    "content": "```typescript\n// --- Config and Core ---\nexport type Config = Readonly<{\n  systemName: string\n  environment: string\n  [CoreNamespace.root]: CoreConfig\n}>\n\nexport type OtelExporterConfig = Readonly<{\n  endpoint?: string\n  headers?: Record<string, string>\n}>\n\nexport type OtelSignalConfig = Readonly<{\n  enabled?: boolean\n  exporter?: OtelExporterConfig\n}>\n\nexport type OtelConfig = Readonly<{\n  serviceName?: string\n  version?: string\n  trace?: OtelSignalConfig\n  logs?: OtelSignalConfig\n  metrics?: OtelSignalConfig\n  exporter?: OtelExporterConfig\n}>\n\nexport type CoreConfig = Readonly<{\n  logging: {\n    logLevel: LogLevelNames\n    logFormat: XOR<LogFormat, readonly LogFormat[]>\n    maxLogSizeInCharacters?: number\n    tcpLoggingOptions?: Readonly<{\n      url: string\n      headers?: Record<string, string | object>\n    }>\n    customLogger?: RootLogger\n    getFunctionWrapLogLevel?: (\n      layerName: string,\n      functionName?: string\n    ) => LogLevelNames\n    ignoreLayerFunctions?: Record<\n      string,\n      boolean | Record<string, Record<string, boolean> | boolean>\n    >\n    otel?: OtelConfig\n  }\n  layerOrder: readonly LayerDescription[]\n  apps: readonly App[]\n  modelFactory?: string\n  modelCruds?: boolean\n  customModelFactory?: NamespaceToFactory\n}>\n\nexport enum CoreNamespace {\n  root = '@node-in-layers/core',\n  globals = '@node-in-layers/core/globals',\n  layers = '@node-in-layers/core/layers',\n  models = '@node-in-layers/core/models',\n  otel = '@node-in-layers/core/otel',\n}\n\nexport type App = Readonly<{\n  name: string\n  description?: string\n  services?: AppLayer<Config, any>\n  features?: AppLayer<Config, any>\n  globals?: GlobalsLayer<Config, any>\n  models?: Record<string, ModelConstructor>\n}>\n\nexport type AppLayer<\n  TConfig extends Config = Config,\n  TContext extends object = object,\n  TLayer extends object = object,\n> = Readonly<{\n  create: (context: LayerContext<TConfig, TContext>) => MaybePromise<TLayer>\n}>\n\nexport type LayerContext<\n  TConfig extends Config = Config,\n  TContext extends object = object,\n> = CommonContext<TConfig> &\n  TContext & {\n    log: LayerLogger\n  }\n\nexport type CommonContext<TConfig extends Config = Config> = Readonly<{\n  config: TConfig\n  rootLogger: RootLogger\n  constants: {\n    environment: string\n    workingDirectory: string\n    runtimeId: string\n  }\n}>\n\n// --- Logging ---\nexport enum LogLevel {\n  TRACE = 0,\n  DEBUG = 1,\n  INFO = 2,\n  WARN = 3,\n  ERROR = 4,\n  SILENT = 5,\n}\n\nexport enum LogLevelNames {\n  trace = 'trace',\n  debug = 'debug',\n  info = 'info',\n  warn = 'warn',\n  error = 'error',\n  silent = 'silent',\n}\n\nexport enum LogFormat {\n  json = 'json',\n  custom = 'custom',\n  simple = 'simple',\n  tcp = 'tcp',\n  otel = 'otel',\n  full = 'full',\n}\n\nexport type LogInstanceOptions = Readonly<{\n  ignoreSizeLimit?: boolean\n}>\n\nexport type Logger = Readonly<{\n  trace: (\n    message: string,\n    dataOrError?: Record<string, JsonAble | object> | ErrorObject,\n    options?: LogInstanceOptions\n  ) => MaybePromise<void>\n  debug: (\n    message: string,\n    dataOrError?: Record<string, JsonAble | object> | ErrorObject,\n    options?: LogInstanceOptions\n  ) => MaybePromise<void>\n  info: (\n    message: string,\n    dataOrError?: Record<string, JsonAble | object> | ErrorObject,\n    options?: LogInstanceOptions\n  ) => MaybePromise<void>\n  warn: (\n    message: string,\n    dataOrError?: Record<string, JsonAble | object> | ErrorObject,\n    options?: LogInstanceOptions\n  ) => MaybePromise<void>\n  error: (\n    message: string,\n    dataOrError?: Record<string, JsonAble | object> | ErrorObject,\n    options?: LogInstanceOptions\n  ) => MaybePromise<void>\n  applyData: (data: Record<string, JsonAble>) => Logger\n  getIdLogger: (name: string, logIdOrKey: LogId | string, id?: string) => Logger\n  getSubLogger: (name: string) => Logger\n  getIds: () => readonly LogId[]\n}>\n\nexport type LayerLogger = Logger &\n  Readonly<{\n    _logWrap: <T, A extends Array<any>>(\n      functionName: string,\n      func: LogWrapAsync<T, A> | LogWrapSync<T, A>\n    ) => (...a: A) => Promise<T> | T\n    _logWrapAsync: <T, A extends Array<any>>(\n      functionName: string,\n      func: LogWrapAsync<T, A>\n    ) => (...a: A) => Promise<T>\n    _logWrapSync: <T, A extends Array<any>>(\n      functionName: string,\n      func: LogWrapSync<T, A>\n    ) => (...a: A) => T\n    getFunctionLogger: (\n      name: string,\n      crossLayerProps?: CrossLayerProps\n    ) => FunctionLogger\n    getInnerLogger: (\n      functionName: string,\n      crossLayerProps?: CrossLayerProps\n    ) => FunctionLogger\n  }>\n\nexport type AppLogger = Logger &\n  Readonly<{\n    getLayerLogger: (\n      layerName: CommonLayerName | string,\n      crossLayerProps?: CrossLayerProps\n    ) => LayerLogger\n  }>\n\nexport type RootLogger<TConfig extends Config = Config> = Readonly<{\n  getLogger: (\n    context: CommonContext<TConfig>,\n    props?: { ids?: readonly LogId[]; data?: Record<string, any> }\n  ) => HighLevelLogger\n}>\n\nexport type LogId = Readonly<Record<string, string>>\n\nexport type LogMessage<\n  T extends Record<string, JsonAble> = Record<string, JsonAble>,\n> = Readonly<{\n  id: string\n  logger: string\n  environment: string\n  ids?: readonly LogId[]\n  logLevel: LogLevelNames\n  datetime: Date\n  message: string\n}> &\n  Partial<ErrorObject> &\n  T\n\nexport type LogFunction = (logMessage: LogMessage) => void | Promise<void>\n\nexport type LogMethod<TConfig extends Config = Config> = (\n  context: CommonContext<TConfig>\n) => LogFunction\n\nexport enum CommonLayerName {\n  models = 'models',\n  services = 'services',\n  features = 'features',\n  entries = 'entries',\n}\n\n// --- Layers, Cross-Layer, and NIL Functions ---\nexport type CrossLayerProps<T extends object = object> = Readonly<{\n  logging?: {\n    ids?: readonly LogId[]\n  }\n}> &\n  T\n\nexport type LayerFunction<T extends (...args: any[]) => any> = T extends (\n  ...args: infer Args\n) => infer ReturnType\n  ? (...args: [...Args, crossLayerProps?: CrossLayerProps]) => ReturnType\n  : never\n\nexport type ErrorObject = Readonly<{\n  error: Readonly<{\n    code: string\n    message: string\n    details?: string\n    data?: Record<string, JsonAble>\n    trace?: string\n    cause?: ErrorObject\n  }>\n}>\n\nexport type Response<R> = XOR<R, ErrorObject>\nexport type TrueMaybePromise<T> = XOR<Promise<T>, T>\n\nexport type NilFunctionReturn<TOutput> = [TOutput] extends [void]\n  ? TrueMaybePromise<void>\n  : TrueMaybePromise<Response<TOutput>>\n\nexport type NilFunction<\n  TProps extends JsonObj,\n  TOutput extends XOR<JsonObj, void>,\n> = (\n  props: TProps,\n  crossLayerProps?: CrossLayerProps\n) => NilFunctionReturn<TOutput>\n\nexport type NilAnnotatedFunction<\n  TProps extends JsonObj,\n  TOutput extends XOR<JsonObj, void>,\n> = NilFunction<TProps, TOutput> &\n  Readonly<{\n    functionName: string\n    domain: string\n    schema: z.ZodFunction<\n      z.ZodTuple<[\n        ZodType<TProps>,\n        ZodType<CrossLayerProps | undefined>,\n      ]>,\n      ZodType<NilFunctionReturn<TOutput>>\n    >\n  }>\n\n// --- Models and CRUD (high level) ---\nexport type ModelConstructor = Readonly<{\n  create: <\n    T extends DataDescription,\n    TModelExtensions extends object = object,\n    TModelInstanceExtensions extends object = object,\n  >(\n    modelProps: ModelProps\n  ) => ModelType<T, TModelExtensions, TModelInstanceExtensions>\n}>\n\nexport type ModelProps<\n  TConfig extends Config = Config,\n  TModelOverrides extends object = object,\n  TModelInstanceOverrides extends object = object,\n> = Readonly<{\n  context: CommonContext<TConfig>\n  Model: ModelFactory<TModelOverrides, TModelOverrides>\n  fetcher: ModelInstanceFetcher<TModelOverrides, TModelInstanceOverrides>\n  getModel: <T extends DataDescription>(\n    namespace: string,\n    modelName: string\n  ) => () => ModelType<T, TModelOverrides, TModelInstanceOverrides>\n}>\n\nexport type ModelCrudsFunctions<\n  TData extends DataDescription,\n  TModelExtensions extends object = object,\n  TModelInstanceExtensions extends object = object,\n> = Readonly<{\n  getModel: () => OrmModel<TData, TModelExtensions, TModelInstanceExtensions>\n  create: CreateFunction<TData>\n  retrieve: RetrieveFunction<TData>\n  update: UpdateFunction<TData>\n  delete: DeleteFunction\n  search: SearchFunction<TData>\n  bulkInsert: BulkInsertFunction<TData>\n  bulkDelete: BulkDeleteFunction\n}>\n\nexport type CreateFunction<TData extends DataDescription> = <\n  IgnoreProperties extends string = '',\n>(\n  data: Omit<TData, IgnoreProperties> | ToObjectResult<TData>\n) => Promise<OrmModelInstance<TData>>\n\nexport type RetrieveFunction<TData extends DataDescription> = (\n  primaryKey: PrimaryKeyType\n) => Promise<OrmModelInstance<TData> | undefined>\n\nexport type UpdateFunction<TData extends DataDescription> = (\n  primaryKey: PrimaryKeyType,\n  data: TData | ToObjectResult<TData>\n) => Promise<OrmModelInstance<TData>>\n\nexport type DeleteFunction = (primaryKey: PrimaryKeyType) => Promise<void>\n\nexport type SearchFunction<TData extends DataDescription> = (\n  ormSearch: OrmSearch\n) => Promise<OrmSearchResult<TData>>\n\nexport type BulkInsertFunction<TData extends DataDescription> = (\n  data: readonly TData[]\n) => Promise<void>\n\nexport type BulkDeleteFunction = (\n  primaryKeys: readonly PrimaryKeyType[]\n) => Promise<void>\n```\n",
    "tags": [
      "types",
      "architecture",
      "models",
      "config",
      "domains"
    ]
  },
  {
    "id": "9f70590a-3ed8-445a-a483-e2c04a93a642",
    "name": "API Surface of @node-in-layers/core",
    "description": "All functions and objects exported from @node-in-layers/core. Each export shows its name, input/output types, and a minimal code snippet. Implementation details are omitted.\n",
    "content": "```typescript\n// From index.ts\nexport { loadSystem } from './entries.js'\nexport * from './types.js'\nexport * from './libs.js'\nexport * from './utils.js'\nexport * from './models/types.js'\nexport * from './globals/logging.js'\nexport * from './globals/libs.js'\n\n// --- Main Function ---\n// entries.ts\nasync function loadSystem<TConfig extends Config = Config>(args: {\n  environment: string\n  config?: TConfig\n}): Promise<any>\n\n// --- Logging (globals/logging.ts) ---\nfunction standardLogger<TConfig extends Config = Config>(): RootLogger<TConfig>\nfunction compositeLogger<TConfig extends Config = Config>(\n  logMethods: readonly LogMethod<TConfig>[]\n): RootLogger<TConfig>\nfunction consoleLogSimple(logMessage: LogMessage): void\nfunction consoleLogJson(logMessage: LogMessage): void\nfunction consoleLogFull(logMessage: LogMessage): void\nfunction logTcp(\n  context: CommonContext\n): (logMessage: LogMessage) => Promise<any>\n\n// --- Types and Model CRUDs (see types entry for curated list) ---\n// Key types from types.ts and models/types.ts are exported\n```\n",
    "tags": [
      "api-surface",
      "architecture",
      "best-practices"
    ]
  },
  {
    "id": "c1c4f0c9-annotated-functions-zod4",
    "name": "Build Features the Right Way (Annotated Functions, Zod 4 — Highly Encouraged)",
    "description": "Highly encouraged: build feature functions with annotatedFunction and Zod 4 for type-safe args/returns, cross-layer tracing, and consistent surfaces for OpenAPI/MCP.",
    "content": "### Build Features the Right Way (Annotated Functions, Zod 4 — Highly Encouraged)\n\nIt’s highly encouraged that feature-level functions use `annotatedFunction` with Zod 4. This provides:\n- Typed args/returns with runtime validation (Zod 4)\n- Cross-layer tracing via the final optional `crossLayerProps`\n- Consistent, discoverable function metadata for documentation and MCP tools\n\n```typescript\nimport { annotatedFunction, FeaturesContext, Config } from '@node-in-layers/core'\nimport { z } from 'zod' // Zod v4\n\nexport const create = (context: FeaturesContext<Config, any>) => {\n  const hello = annotatedFunction(\n    {\n      functionName: 'hello',\n      domain: 'greetings',\n      description: 'Greets a user by name.',\n      args: z.object({ name: z.string() }),\n      returns: z.object({ greeting: z.string() }),\n    },\n    (args, crossLayerProps) => {\n      const log = context.log.getInnerLogger('hello', crossLayerProps)\n      log.info('Greeting user', { name: args.name })\n      return { greeting: `Hello ${args.name}` }\n    }\n  )\n\n  return { hello }\n}\n```\n\n> Use Zod 4 explicitly. Using `annotatedFunction` is highly encouraged for building features the right way.",
    "tags": [
      "features",
      "zod4",
      "annotatedFunction",
      "best-practices",
      "mcp"
    ]
  }
]