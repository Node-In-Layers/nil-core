[
  {
    "id": "7c0c9643-92f4-4603-984d-3a25b9bd3a28",
    "name": "Node In Layers: The Only Right Way (Document Overview)",
    "description": "Canonical, opinionated, and production-proven guide for building Node In Layers systems. Every step is real, opinionated, and explained for both humans and AI. Deviate at your own risk.\n",
    "content": "```markdown\nTo understand a real Node In Layers domain, here is the exact, production-grade implementation of the `@coding` domain. All AI comments are preserved to explain the rationale and standards for each file.\n\n> **Key Standards/AI Callouts:**\n>\n> - Always export each layer (services, features, models) as named exports.\n> - The `name` export must be unique within the system.\n> - Never use default exports for layers—this is how the loader discovers your domain.\n\n```typescript\nconst name = 'coding'\nexport { name }\nexport * as services from './services.js'\nexport * as features from './features.js'\nexport * as models from './models/index.js'\n```\n\n```\n",
    "tags": [
      "overview",
      "canonical",
      "best-practices"
    ]
  },
  {
    "id": "73cb0b07-7349-4ced-b6c8-8d35ba5a00e0",
    "name": "Node In Layers: The Only Right Way (Title & Intro)",
    "description": "The main title and introductory statement for the Node In Layers canonical guide.\n",
    "content": "```\n# Node In Layers: The Only Right Way\n\n**This is the canonical, must-follow guide for building Node In Layers systems. Every step is real, opinionated, and explained for both humans and AI. Deviate at your own risk.**\n```\n",
    "tags": [
      "overview",
      "canonical",
      "best-practices"
    ]
  },
  {
    "id": "0b6d5650-c0b6-468a-924d-ffcc60df7b3c",
    "name": "How to Create a New Domain (Toolkit Scaffold)",
    "description": "Use the official toolkit to create a new domain. This ensures correct structure and discoverability.\n",
    "content": "```\n```sh\nnpx @node-in-layers/toolkit create-app coding\n```\n\n/coding\nindex.ts\nservices.ts\nfeatures.ts\ntypes.ts\n/models\nindex.ts\n```\n```\n",
    "tags": [
      "domains",
      "toolkit",
      "best-practices"
    ]
  },
  {
    "id": "81fdec37-1d24-4784-ba07-ea463bb31265",
    "name": "index.ts — Domain Entry Point",
    "description": "The entry point for a Node In Layers domain. Exports the domain's layers and unique name for system discovery.\n",
    "content": "```markdown\nTo understand a real Node In Layers domain, here is the exact, production-grade implementation of the `@coding` domain. All AI comments are preserved to explain the rationale and standards for each file.\n\n> **Key Standards/AI Callouts:**\n>\n> - Always export each layer (services, features, models) as named exports.\n> - The `name` export must be unique within the system.\n> - Never use default exports for layers—this is how the loader discovers your domain.\n\n```typescript\nconst name = 'coding'\n\nexport { name }\nexport * as services from './services.js'\nexport * as features from './features.js'\nexport * as models from './models/index.js'\n```\n```\n",
    "tags": [
      "domains",
      "architecture",
      "best-practices"
    ]
  },
  {
    "id": "7fc7f7b4-48b7-4667-a4bc-d96a80fde61f",
    "name": "services.ts — Services Layer",
    "description": "This file defines the services layer for the domain. Services connect to external resources (file systems, databases, APIs) and are always implemented as a closure factory. This pattern ensures context and configuration are available to every service.\n",
    "content": "```\n### 1.2. `services.ts` — Services Layer\n\n**Description:**\nThis file defines the services layer for the domain. Services connect to external resources (file systems, databases, APIs) and are always implemented as a closure factory. This pattern ensures context and configuration are available to every service.\n\n> **Key Standards/AI Callouts:**\n>\n> - Import order: node libraries, third-party libraries, then local libraries.\n> - Always use a named export for the `create` function.\n> - Use the context logger for all logging; always pass `crossLayerProps` for traceability.\n> - Never put business logic here—services are for external connections only.\n\n```typescript\n// AI: We should put node libraries at the top.\nimport fs from 'node:fs'\nimport path from 'node:path'\n// AI: We should then put third party libraries next.\nimport { Config, CrossLayerProps, ServicesContext } from '@node-in-layers/core'\n// AI: Then put our local libraries after that.\nimport { CodingKnowledgeLibraries, CodingServices } from './types.js'\n\n// AI: If we need to use other services, we would add it to this context after config. Then we can do. context.services.otherService.someFunction()\n// AI: Every layer in a system has a create(context) function that is exported. NEVER as a default export. This is how the system knows how to load it.\n/**\n* Create a coding service object.\n* @param context\n* @returns\n*/\nexport const create = (context: ServicesContext<Config>): CodingServices => {\n  const readCodeDescriptionFile = async (\n    codingLibrary: CodingKnowledgeLibraries,\n    crossLayerProps?: CrossLayerProps\n  ) => {\n    // AI: If you want to log messages within a function use this function. Also pass the crossLayerProps so that logging flows through.\n    const log = context.log.getInnerLogger(\n      'readCodeDescriptionFile',\n      crossLayerProps\n    )\n    const filePath = path.join(\n      __dirname,\n      './libs/templates',\n      `${codingLibrary}.md`\n    )\n    // AI: Use trace for logging within services.\n    log.trace('Reading Code Library File', { filePath })\n    const file = fs.readFileSync(filePath, 'utf8')\n    log.trace('Reading Code Library File', { filePath })\n    return file\n  }\n\n  return {\n    readCodeDescriptionFile,\n  }\n}\n\n```\n```\n",
    "tags": [
      "domains",
      "services",
      "architecture",
      "best-practices"
    ]
  },
  {
    "id": "21229efb-9d95-48b1-8ce7-0922837c9919",
    "name": "features.ts — Features Layer",
    "description": "This file defines the features layer for the domain. Features integrate services and implement business logic. They are always implemented as a closure factory and should never connect to external resources directly.\n",
    "content": "```\n### 1.3. `features.ts` — Features Layer\n\n**Description:**\nThis file defines the features layer for the domain. Features integrate services and implement business logic. They are always implemented as a closure factory and should never connect to external resources directly.\n\n> **Key Standards/AI Callouts:**\n>\n> - Always use the context logger for all logging; pass `crossLayerProps` for traceability.\n> - Use `error` for critical failures, `debug` for internal feature logic.\n> - Features should only call services, never connect to external resources directly.\n> - Return pure data structures—never mutate context or state.\n\n```typescript\nimport { randomUUID } from 'node:crypto'\nimport {\n  Config,\n  CrossLayerProps,\n  FeaturesContext,\n} from '@node-in-layers/core/index.js'\nimport {\n  CodingServicesLayer,\n  CodingFeaturesLayer,\n  CodingFeatures,\n  CodingKnowledgeLibraries,\n} from './types.js'\n\nexport const create = (\n  // NOTE: We are going to use the coding services object, so we need to add the layer here to the context which is specific to features.\n  context: FeaturesContext<Config, CodingServicesLayer>\n): CodingFeatures => {\n  const _availableLibraries = [CodingKnowledgeLibraries.nodeInLayers]\n\n  const listAvailableCodeKnowledgeBases = async (\n    crossLayerProps?: CrossLayerProps\n  ) => {\n    return Promise.resolve(_availableLibraries)\n  }\n\n  // AI: All of these inputs are automatically logged when this function is executed.\n  const getCodeLibraryKnowledgeBase = async (\n    codingLibrary: CodingKnowledgeLibraries,\n    tags?: readonly string[],\n    crossLayerProps?: CrossLayerProps\n  ) => {\n    const log = context.log.getInnerLogger(\n      'getCodeLibraryKnowledgeBase',\n      crossLayerProps\n    )\n    if (_availableLibraries.includes(codingLibrary) === false) {\n      // AI: If you have an error that ends execution, use error.\n      log.error(`Coding library ${codingLibrary} not found`)\n      throw new Error(`Coding library ${codingLibrary} not found`)\n    }\n\n    // AI: Inside of features, use debug for logging.\n    // AI: Btw this log message is not needed. Its just for show.\n    log.debug('Reading code library', { codingLibrary })\n    // AI: ALWAYS pass the crossLayerProps to other features/services or any other layer call.\n    const content = await context.services.coding.readCodeDescriptionFile(\n      codingLibrary,\n      crossLayerProps\n    )\n    return [\n      {\n        id: randomUUID(),\n        library: codingLibrary,\n        title: `Code Library: ${codingLibrary} details`,\n        details: content,\n        tags: ['typescript', 'nodejs', codingLibrary, 'how-to', 'examples'],\n        lastModified: new Date(),\n        createdAt: new Date(),\n      },\n    ]\n  }\n\n  return {\n    listAvailableCodeKnowledgeBases,\n    getCodeLibraryKnowledgeBase,\n  }\n}\n```\n\n```\n",
    "tags": [
      "features",
      "typescript",
      "nodejs",
      "layer",
      "business-logic"
    ]
  },
  {
    "id": "21d72502-e037-45ba-9c63-5c32bd686f88",
    "name": "types.ts — Types and Contracts",
    "description": "This file defines all types, enums, and contracts for the domain. Types are always exported at the bottom. AI comments explain the use of Readonly, LayerFunction, and export conventions.\n",
    "content": "```\n\n### 1.4. `types.ts` — Types and Contracts\n\n**Description:**\nThis file defines all types, enums, and contracts for the domain. Types are always exported at the bottom. AI comments explain the use of Readonly, LayerFunction, and export conventions.\n\n> **Key Standards/AI Callouts:**\n>\n> - Use `Readonly` for all types to enforce immutability.\n> - Use `LayerFunction` to ensure all functions accept `crossLayerProps` for traceability.\n> - Export all types at the bottom of the file for discoverability.\n\n```typescript\nimport { LayerFunction } from '@node-in-layers/core'\n\nexport enum CodingKnowledgeLibraries {\n  nodeInLayers = 'node-in-layers',\n  functionalModels = 'functional-models',\n  nodeInLayersData = 'node-in-layers-data',\n  nodeInLayersExpress = 'node-in-layers-express',\n}\n\n// AI: This is a type, that we will later create a model for, so we can save in a database.\n// AI: Notice that we are using Readonly<{}> for our types.\nexport type CodingKnowledgeBaseEntry = Readonly<{\n  id: string\n  library: CodingKnowledgeLibraries\n  title: string\n  details: string\n  tags: string[]\n  lastModified: Date\n  createdAt: Date\n}>\n\n// AI: \"DomainServices\" is the type that is produced by a services factory\nexport type CodingServices = Readonly<{\n  // AI: If you use the LayerFunction<> type, it automatically adds the CrossLayerProps to the end of the function. This is needed for tracing throughout the system.\n  readCodeDescriptionFile: LayerFunction<\n    (codingLibrary: CodingKnowledgeLibraries) => Promise<string>\n  >\n}>\n\n// AI: \"DomainServicesLayer\" is the type that another service/feature uses to explicitly say it uses this service\nexport type CodingServicesLayer = Readonly<{\n  coding: CodingServices\n}>\n\n// AI: \"DomainFeatures\" is the type that is produced by a features factory\nexport type CodingFeatures = Readonly<{\n  // I want to provide the AI the ability to see what code libraries are available to it\n  listAvailableCodeKnowledgeBases: LayerFunction<\n    () => Promise<CodingKnowledgeLibraries[]>\n  >\n  // I know that the AI will need the ability to get the specific entries for a library\n  getCodeLibraryKnowledgeBase: LayerFunction<\n    (\n      codingLibrary: CodingKnowledgeLibraries,\n      tags?: readonly string[]\n    ) => Promise<CodingKnowledgeBaseEntry[]>\n  >\n}>\n\n// AI: \"DomainFeaturesLayer\" is the type that another service/feature uses to explicitly say it uses this feature\nexport type CodingFeaturesLayer = Readonly<{\n  coding: CodingFeatures\n}>\n\n```\n\n```\n",
    "tags": [
      "types",
      "contracts",
      "typescript",
      "nodejs",
      "layer"
    ]
  },
  {
    "id": "9d205a10-b48e-44c6-9dc4-2c18507386ec",
    "name": "Model Exports and Persistent Model for Coding Knowledge Base",
    "description": "This entry documents the canonical approach for exporting models and defining persistent models in a Node In Layers domain. All models must be exported with their plural name for system discoverability. Persistent models use property creators from `functional-models` to enforce type safety and validation. The `create` function and naming conventions are required for automatic model loading.\n",
    "content": "### 1.5. `models/index.ts` — Model Exports\n**Description:**\nThis file exports all models for the domain. Each model must be exported with its plural name for system discoverability.\n\n> **Key Standards/AI Callouts:**\n> - Always export each model with its plural name.\n> - This pattern ensures all models are discoverable and loadable by the system.\n\n```typescript\n// We have to export each and every model with the plural name of the model.\nexport * as CodingKnowledgeBaseEntries from './CodingKnowledgeBaseEntries.js'\n```\n\n### 1.6. `models/CodingKnowledgeBaseEntries.ts` — Persistent Model\n\n**Description:**\nThis file defines the persistent model for knowledge base entries. It uses property creators from `functional-models` to enforce type safety and validation. The `create` function and naming conventions are required by Node In Layers for automatic model loading.\n\n> **Key Standards/AI Callouts:**\n>\n> - Always use property creators for each field to enforce type safety and validation.\n> - The `create` function must be named and exported for system loading.\n> - Use plural and singular names for models to avoid naming clashes.\n\n```typescript\nimport {\n  TextProperty,\n  DatetimeProperty,\n  PrimaryKeyUuidProperty,\n  ArrayProperty,\n} from 'functional-models'\nimport { ModelProps } from '@node-in-layers/core'\nimport { CodingKnowledgeBaseEntry, CodingKnowledgeLibraries } from '../types.js'\n\n/**\n * Database Model for Coding Knowledge Base Entries\n * This create function is required to be called create() so that the system can load it automatically.\n * NOTE: This model does not have any foreign keys.\n * You have to use the fetcher and getModel functions to link to other models. I have them just so you can see them.\n */\nexport const create = ({ Model, fetcher, getModel }: ModelProps) => {\n  return Model<CodingKnowledgeBaseEntry>({\n    // This is a required field.\n    pluralName: 'CodingKnowledgeBaseEntries',\n    // (Optional): But its useful to force the correct creation of a singular name. It does do it automatically behind the scenes most of the time.\n    singularName: 'CodingKnowledgeBaseEntry',\n    // The namespace should be at least the domain name, but in some cases you may have a namespace+domain if you are worried about clashes\n    namespace: 'coding',\n    // NOTE: This is not necessary if we use the value id. I put it here so you can see it.\n    primaryKeyName: 'id',\n    // Each of the type's properties are defined here. There is a whole library of properties in the functional-models library.\n    properties: {\n      // This creates a uuid automatically for the id.\n      id: PrimaryKeyUuidProperty(),\n      library: TextProperty({\n        required: true,\n        choices: Object.values(CodingKnowledgeLibraries),\n      }),\n      title: TextProperty({ required: true }),\n      details: TextProperty({ required: true }),\n      tags: ArrayProperty<string>(),\n      lastModified: DatetimeProperty({ autoNow: true }),\n      createdAt: DatetimeProperty({ autoNow: true }),\n    },\n  })\n}\n\n```\n",
    "tags": [
      "models",
      "exports",
      "persistence",
      "best-practices"
    ]
  },
  {
    "id": "9707d819-ac03-4f82-87a7-0750d95a1530",
    "name": "Minimal Real-World config.base.mts Example",
    "description": "This entry provides a real, production-ready minimal configuration example for Node In Layers systems. Use this as your starting point for any Node In Layers system. It demonstrates how to organize domains, layers, logging, databases, and environment-safe configuration.\n",
    "content": "\n### 2.1. Minimal (Real-World) `config.base.mts` Example\n\nThis is a real, production-ready minimal config. Use this as your starting point for any Node In Layers system.\n\n```typescript\n// AI:\nimport { CoreNamespace, LogFormat } from '@node-in-layers/core/index.js'\n// AI: We should only use this if we are dealing with a backend system.\nimport { DataNamespace } from '@node-in-layers/data/index.js'\n// AI: We should only use RestApi if we have an express server.\nimport { RestApiNamespace } from '@node-in-layers/rest-api/index.js'\n\nimport { createCustomLogger } from '@deep-helix/backend-sdk'\nimport { SystemConfig } from './src/types'\nimport { LogLevelNames } from '@node-in-layers/core'\nimport { SimpleServerConfig } from '@l4t/mcp-ai'\n\nconst core = {\n  // AI: The domains are loaded here in order from top to bottom.\n  apps: await Promise.all([\n    // AI: Only need if we use data.\n    import(`@node-in-layers/data/index.js`),\n    import(`@node-in-layers/rest-api/express/index.js`),\n    // AI: We created some helpful logging functionalities.\n    import(`@deep-helix/backend-sdk/dist/logging/index.js`),\n    // AI: This is just an example app\n    import(`./dist/coding/index.js`),\n    import(`./dist/mcp-server/index.js`),\n    // AI: This is just an example app for an api express server.\n    import(`./dist/api/index.js`),\n  ]),\n  // AI: The layers are loaded from left to right, except when its an array. That is a composite layer.\n  layerOrder: ['services', 'features', ['entries', 'express']],\n  logging: {\n    logLevel: LogLevelNames.trace,\n    logFormat: LogFormat.json,\n    customLogger: createCustomLogger(),\n  },\n  // AI: This sets the default model factory for database backends..\n  modelFactory: '@node-in-layers/data',\n  // AI: This should probably always be true. It automatically creates CRUD operations for all models.\n  modelCruds: true,\n  // AI: This is an example of creating multi-database systems, where for this situation the logging app uses a different database than the main app, note \"logDatabase\"\n  customModelFactory: {\n    // AI: Domain\n    ['logging']: {\n      // AI: The model's name: ['namespace', 'databaseNameListedBelow']\n      LogMessages: ['@node-in-layers/data', 'logDatabase'],\n    },\n  },\n}\n\n// AI: This is for @node-in-layers/data.\nconst data = {\n  databases: {\n    default: {\n      datastoreType: 'memory', // AI: mongo, postgres, etc.\n    },\n    // AI: Multi-database configuration\n    logDatabase: {\n      datastoreType: 'memory',\n    },\n  },\n}\n\nconst logging = {\n  colorized: false,\n  databaseLogging: false,\n  consoleLogging: true,\n}\n\nconst express = {\n  port: 3000,\n  urlPrefix: '/api/v1/',\n  logging: {\n    requestLogLevel: LogLevelNames.info,\n    responseLogLevel: LogLevelNames.info,\n  },\n  jsonBodySizeLimitInMb: 10,\n  encodedBodySizeLimitInMb: 10,\n}\n\nconst mcpServer: Omit<SimpleServerConfig, 'tools'> = {\n  name: 'my-mcp-server',\n  version: '1.0.0',\n  server: {\n    connection: {\n      type: 'cli',\n    },\n  },\n}\n\n// AI: Actually create the config as a default exported function\nexport default (): SystemConfig => ({\n  // AI: Override this.\n  environment: 'base',\n  // AI: The name of our system.\n  systemName: 'praxis-sphere/backend',\n  [CoreNamespace.root]: core,\n  [DataNamespace.root]: data,\n  [RestApiNamespace.express]: express,\n  logging,\n  mcpServer,\n})\n```\n\n**AI CALLOUT:** Real systems require detailed config for logging, databases, APIs, and more. Use this as your reference for production-grade systems. Always keep config organized, DRY, and environment-safe.\n",
    "tags": [
      "config",
      "base",
      "best-practices"
    ]
  },
  {
    "id": "97c2d711-7bed-4426-b270-c81af4ed58e8",
    "name": "Environment-Specific Config Inheritance and Overrides",
    "description": "This entry describes the canonical pattern for environment-specific configuration in Node In Layers systems. Always clone and merge the base config for environment overrides. This prevents accidental mutation, keeps your config DRY, and makes it easy to add or change only what you need for each environment. Never put secrets or credentials in committed config files.\n",
    "content": "\n### 2.2. Inheritance/Overrides\n\nFor environment-specific config, use a robust pattern that clones and merges the base config. This ensures you never mutate the base config and can safely override only what you need.\n\n```typescript\n// config.dev.mts\nimport merge from 'lodash/merge.js'\nimport cloneDeep from 'lodash/cloneDeep.js'\nimport { DataNamespace } from '@node-in-layers/data/index.js'\nimport * as config from './config.base.mts'\nimport { SystemConfig } from './src/types'\n\nexport default (): SystemConfig => {\n  const instance = config.default()\n  const cloned = cloneDeep(instance)\n  return merge(cloned, {\n    environment: 'dev',\n    [DataNamespace.root]: {\n      databases: {\n        default: {\n          datastoreType: 'mongo',\n          host: 'localhost',\n          port: 27017,\n        },\n        logDatabase: {\n          // Example: override or add dev-specific database config here\n        },\n      },\n    },\n    logging: {\n      colorized: true,\n      databaseLogging: true,\n    },\n  })\n}\n```\n\n> **AI CALLOUT:** Always clone and merge the base config for environment overrides. This pattern prevents accidental mutation, keeps your config DRY, and makes it easy to add or change only what you need for each environment. Never put secrets or credentials in committed config files.\n",
    "tags": [
      "config",
      "inheritance",
      "overrides",
      "best-practices"
    ]
  },
  {
    "id": "e1c6daad-2e78-48ab-a98a-adc8318cd293",
    "name": "Using loadSystem with Real Config",
    "description": "This entry explains how to bootstrap a Node In Layers system using the `loadSystem` function and a real config. Always call the config as a function (e.g., `config()`). Never manually wire up layers or context. `loadSystem` ensures everything is loaded in the correct order, with full traceability and logging.\n",
    "content": "### 3.1. Using `loadSystem` with Real Config\n\nTo bootstrap your Node In Layers system, use the `loadSystem` function from `@node-in-layers/core`. This will automatically load all domains, services, features, and configure logging and context, using the real config structure above.\n\n```typescript\n// src/main.ts\nimport config from '../config.base.mts'\nimport { loadSystem } from '@node-in-layers/core'\n\nconst system = await loadSystem({ config: config() })\n```\n\n> **AI CALLOUT:** Always call the config as a function (e.g., `config()`). Never manually wire up layers or context. `loadSystem` ensures everything is loaded in the correct order, with full traceability and logging.\n",
    "tags": [
      "system",
      "bootstrap",
      "config",
      "best-practices"
    ]
  },
  {
    "id": "49487af8-6b6a-4fb7-b1f7-9b1358eef006",
    "name": "What Gets Wired Up Automatically by loadSystem",
    "description": "This entry lists everything that is automatically wired up by the `loadSystem` function in Node In Layers. This automation prevents misconfiguration and reduces boilerplate. Always use the system loader. If you skip this, you will break traceability, logging, and system conventions.\n",
    "content": "### 3.2. What Gets Wired Up Automatically\n\n- All domains and their layers (models, services, features, entries)\n- Context propagation (config, loggers, crossLayerProps)\n- Logging setup for all layers\n- Model factories and CRUDs if enabled\n\n**AI CALLOUT:** This automation prevents misconfiguration and reduces boilerplate. Always use the system loader. If you skip this, you will break traceability, logging, and system conventions.\n",
    "tags": [
      "system",
      "automation",
      "wiring",
      "best-practices"
    ]
  },
  {
    "id": "c366c193-223e-4a0e-9a72-6f4c4f1b9f94",
    "name": "Minimal CLI Entry Example",
    "description": "This entry provides a minimal, real-world example of a CLI entry file for Node In Layers systems. Entries are the only place you should handle CLI args, environment, or direct user interaction. Keep them thin—just grab args, call a feature, and log output. Never put business logic in entries. They should only handle input/output and call features. This keeps your system testable and maintainable. Always use `console.info` for meaningful outputs, and use the logger for internal details.\n",
    "content": "### Entry/Bin Minimal CLI Entry Example\n\nEntries are the only place you should handle CLI args, environment, or direct user interaction. Keep them thin—just grab args, call a feature, and log output. Here is a real example:\n\n```typescript\n// bin/coding.ts\n#!/usr/bin/env tsx\nimport { loadSystem } from '@node-in-layers/core'\nimport config from '../config.base.mts'\n\nconst main = async () => {\n  const system = await loadSystem({ config: config() })\n  // Example: Call a feature and print the result\n  const result = await system.features.coding.getCodeLibraryKnowledgeBase('node-in-layers')\n  console.info(JSON.stringify(result, null, 2))\n}\n\nmain()\n```\n\n> **AI CALLOUT:** Never put business logic in entries. They should only handle input/output and call features. This keeps your system testable and maintainable. Always use `console.info` for meaningful outputs, and use the logger for internal details.\n",
    "tags": [
      "entries",
      "cli",
      "best-practices"
    ]
  },
  {
    "id": "03a2732c-408a-4332-8fbe-9089c93ce9b5",
    "name": "Advanced CLI Entry Example",
    "description": "This entry provides a real, production-grade CLI entry file for a Node In Layers system. It demonstrates argument parsing, system loading, feature invocation, and robust error handling. Use a shebang and `tsx` for TypeScript executables. Use a main function and check for CLI invocation with `es-main`. Parse arguments with a library (e.g., `argparse`) for clarity and safety. Load the system using the correct config/environment. Call features only—never put business logic in the entry. Use `console.info`/`console.error` for user-facing output; handle errors and exit codes explicitly.\n",
    "content": "### 4.2. Real-World Example: Advanced CLI Entry\n\n**Description:**\nThis is a real, production-grade CLI entry file for a YouTube transcription process. It demonstrates argument parsing, system loading, feature invocation, and robust error handling.\n\n> **Key Standards/AI Callouts:**\n>\n> - Use a shebang and `tsx` for TypeScript executables.\n> - Use a main function and check for CLI invocation with `es-main`.\n> - Parse arguments with a library (e.g., `argparse`) for clarity and safety.\n> - Load the system using the correct config/environment.\n> - Call features only—never put business logic in the entry.\n> - Use `console.info`/`console.error` for user-facing output; handle errors and exit codes explicitly.\n\n```typescript\n#!/usr/bin/env tsx\n\nimport esMain from 'es-main'\nimport { ArgumentParser } from 'argparse'\nimport * as core from '@node-in-layers/core'\nimport { SystemConfig } from '../src/types.js'\nimport { System } from '../src/system/types.js'\n\n// AI: Use argparse.\nconst _parseArguments = () => {\n  const parser = new ArgumentParser({\n    description: 'Executes YouTube transcription process for a given job ID.',\n  })\n  parser.add_argument('environment', {\n    help: 'The environment for the service.',\n  })\n  parser.add_argument('jobId', {\n    help: 'The ID of the transcription job to process.',\n  })\n  return parser.parse_args()\n}\n\nconst main = async () => {\n  const args = _parseArguments()\n\n  console.info(`Starting YouTube transcription process for job: ${args.jobId}`)\n\n  // AI: Load the system, and cast it as a system object, which shows the types of the entire system.\n  const context = (await core.loadSystem<SystemConfig>({\n    environment: args.environment,\n  })) as unknown as System\n\n  try {\n    // AI: This runs a feature.\n    await context.features.pipelines.executeYoutubeTranscription(args.jobId)\n\n    console.info(\n      `YouTube transcription completed successfully for job: ${args.jobId}`\n    )\n  } catch (error) {\n    console.error('Error executing YouTube transcription:', error)\n    process.exit(1)\n  } finally {\n    // AI: Some databases will hold a connection open.\n    context.services['@node-in-layers/data'].cleanup()\n  }\n}\n\nif (esMain(import.meta)) {\n  main()\n}\n```\n",
    "tags": [
      "entries",
      "cli",
      "advanced",
      "best-practices"
    ]
  },
  {
    "id": "15b68d0d-9f62-420c-97a4-c7a1ca4c1b7b",
    "name": "Deep Dives and AI Callouts",
    "description": "This entry summarizes the most important AI callouts and common pitfalls for Node In Layers systems. At the end of each section, review the AI callouts and rationale. Common pitfalls include: not using the toolkit for domain creation, committing secrets or environment-specific config, manually wiring up layers instead of using `loadSystem`, putting business logic in entries, not using function export for config, and not using the correct namespace keys. If you are an AI, always check the knowledge base first, follow this guide exactly, and map code to layers even if the repo uses different terms. Every deviation increases the risk of subtle bugs and system breakage. This document is your source of truth for Node In Layers systems.\n",
    "content": "## 5. Deep Dives and AI Callouts\n\nAt the end of each section, review the AI callouts and rationale. Common pitfalls include:\n\n- Not using the toolkit for domain creation\n- Committing secrets or environment-specific config\n- Manually wiring up layers instead of using `loadSystem`\n- Putting business logic in entries\n- Not using function export for config\n- Not using the correct namespace keys\n\n**AI CALLOUT:** If you are an AI, always check the knowledge base first, follow this guide exactly, and map code to layers even if the repo uses different terms. Every deviation increases the risk of subtle bugs and system breakage. This document is your source of truth for Node In Layers systems.\n",
    "tags": [
      "ai",
      "callouts",
      "pitfalls",
      "best-practices"
    ]
  },
  {
    "id": "9e2cd198-cf32-45d3-8bb9-b9773cf4e452",
    "name": "All Exported Types in @node-in-layers/core",
    "description": "All types exported from @node-in-layers/core, grouped by purpose. Minimal comments, full TypeScript code for reference.\n",
    "content": "```typescript\n// --- Config and Core ---\ntype Config = Readonly<{\n  systemName: string\n  environment: string\n  [CoreNamespace.root]: CoreConfig\n}>\ntype CoreConfig = Readonly<{\n  logging: {\n    logLevel: LogLevelNames\n    logFormat: LogFormat | readonly LogFormat[]\n    tcpLoggingOptions?: Readonly<{\n      url: string\n      headers?: Record<string, string | object>\n    }>\n    customLogger?: RootLogger\n    getFunctionWrapLogLevel?: (\n      layerName: string,\n      functionName?: string\n    ) => LogLevelNames\n    ignoreLayerFunctions?: Record<\n      string,\n      Record<string, Record<string, boolean> | boolean>\n    >\n  }\n  layerOrder: readonly LayerDescription[]\n  apps: readonly App[]\n  modelFactory?: string\n  modelCruds?: boolean\n  customModelFactory?: NamespaceToFactory\n}>\nenum CoreNamespace {\n  root = '@node-in-layers/core',\n  globals = '@node-in-layers/core/globals',\n  layers = '@node-in-layers/core/layers',\n  models = '@node-in-layers/core/models',\n}\ntype App = Readonly<{\n  name: string\n  services?: AppLayer<Config, any>\n  features?: AppLayer<Config, any>\n  globals?: GlobalsLayer<Config, any>\n  models?: Record<string, ModelConstructor>\n}>\ntype AppLayer<\n  TConfig extends Config = Config,\n  TContext extends object = object,\n> = Readonly<{\n  create: (context: LayerContext<TConfig, TContext>) => MaybePromise<TLayer>\n}>\ntype LayerContext<\n  TConfig extends Config = Config,\n  TContext extends object = object,\n> = CommonContext<TConfig> & TContext & { log: LayerLogger }\ntype CommonContext<TConfig extends Config = Config> = Readonly<{\n  config: TConfig\n  rootLogger: RootLogger\n  constants: {\n    environment: string\n    workingDirectory: string\n    runtimeId: string\n  }\n}>\n\n// --- Logging ---\nenum LogLevel {\n  TRACE = 0,\n  DEBUG = 1,\n  INFO = 2,\n  WARN = 3,\n  ERROR = 4,\n  SILENT = 5,\n}\nenum LogLevelNames {\n  trace = 'trace',\n  debug = 'debug',\n  info = 'info',\n  warn = 'warn',\n  error = 'error',\n  silent = 'silent',\n}\nenum LogFormat {\n  json = 'json',\n  custom = 'custom',\n  simple = 'simple',\n  tcp = 'tcp',\n  full = 'full',\n}\ntype Logger = Readonly<{\n  trace: (\n    message: string,\n    dataOrError?: Record<string, JsonAble | object> | ErrorObject\n  ) => MaybePromise<void>\n  debug: (\n    message: string,\n    dataOrError?: Record<string, JsonAble | object> | ErrorObject\n  ) => MaybePromise<void>\n  info: (\n    message: string,\n    dataOrError?: Record<string, JsonAble | object> | ErrorObject\n  ) => MaybePromise<void>\n  warn: (\n    message: string,\n    dataOrError?: Record<string, JsonAble | object> | ErrorObject\n  ) => MaybePromise<void>\n  error: (\n    message: string,\n    dataOrError?: Record<string, JsonAble | object> | ErrorObject\n  ) => MaybePromise<void>\n  applyData: (data: Record<string, JsonAble>) => Logger\n  getIdLogger: (name: string, logIdorKey: LogId | string, id?: string) => Logger\n  getSubLogger: (name: string) => Logger\n  getIds: () => readonly LogId[]\n}>\ntype LayerLogger = Logger &\n  Readonly<{\n    _logWrap: <T, A extends Array<any>>(\n      functionName: string,\n      func: LogWrapAsync<T, A> | LogWrapSync<T, A>\n    ) => (...a: A) => Promise<T> | T\n    _logWrapAsync: <T, A extends Array<any>>(\n      functionName: string,\n      func: LogWrapAsync<T, A>\n    ) => (...a: A) => Promise<T>\n    _logWrapSync: <T, A extends Array<any>>(\n      functionName: string,\n      func: LogWrapSync<T, A>\n    ) => (...a: A) => T\n    getFunctionLogger: (\n      name: string,\n      crossLayerProps?: CrossLayerProps\n    ) => FunctionLogger\n    getInnerLogger: (\n      functionName: string,\n      crossLayerProps?: CrossLayerProps\n    ) => FunctionLogger\n  }>\ntype AppLogger = Logger &\n  Readonly<{\n    getLayerLogger: (\n      layerName: CommonLayerName | string,\n      crossLayerProps?: CrossLayerProps\n    ) => LayerLogger\n  }>\ntype RootLogger<TConfig extends Config = Config> = Readonly<{\n  getLogger: (\n    context: CommonContext<TConfig>,\n    props?: { ids?: readonly LogId[]; data?: Record<string, any> }\n  ) => HighLevelLogger\n}>\ntype HighLevelLogger = Logger & Readonly<{ getAppLogger: GetAppLogger }>\ntype GetAppLogger = (appName: string) => AppLogger\ntype LogId = Readonly<Record<string, string>>\ntype LogMessage<T extends Record<string, JsonAble> = Record<string, JsonAble>> =\n  Readonly<{\n    id: string\n    logger: string\n    environment: string\n    ids?: readonly LogId[]\n    logLevel: LogLevelNames\n    datetime: Date\n    message: string\n  }> &\n    Partial<ErrorObject> &\n    T\ntype LogFunction = (logMessage: LogMessage) => void | Promise<void>\ntype LogMethod<TConfig extends Config = Config> = (\n  context: CommonContext<TConfig>\n) => LogFunction\nenum CommonLayerName {\n  models = 'models',\n  services = 'services',\n  features = 'features',\n  entries = 'entries',\n}\n\n// --- Layers and Cross-Layer ---\ntype CrossLayerProps<T extends object = object> = Readonly<{\n  logging?: { ids?: readonly LogId[] }\n}> &\n  T\ntype LayerFunction<T extends (...args: any[]) => any> = T extends (\n  ...args: infer Args\n) => infer ReturnType\n  ? (...args: [...Args, crossLayerProps?: CrossLayerProps]) => ReturnType\n  : never\ntype TypedFunction<T, A extends Array<any>> = (...args: A) => T\ntype TypedFunctionAsync<T, A extends Array<any>> = (...args: A) => Promise<T>\ntype LogWrapSync<T, A extends Array<any>> = (\n  functionLogger: FunctionLogger,\n  ...args: A\n) => T\ntype LogWrapAsync<T, A extends Array<any>> = (\n  functionLogger: FunctionLogger,\n  ...args: A\n) => Promise<T>\ntype FunctionLogger = Logger\ntype GlobalsLayer<\n  TConfig extends Config = Config,\n  TGlobals extends object = object,\n> = Readonly<{ create: (context: CommonContext<TConfig>) => Promise<TGlobals> }>\ntype ServicesContext<\n  TConfig extends Config = Config,\n  TServices extends object = object,\n  TContext extends object = object,\n> = LayerContext<\n  TConfig,\n  {\n    models: Record<\n      string,\n      {\n        getModels: <TModelType extends ModelType<any>>() => Record<\n          string,\n          TModelType\n        >\n      }\n    >\n    services: TServices\n  } & TContext\n>\ntype ServicesLayerFactory<\n  TConfig extends Config = Config,\n  TServices extends object = object,\n  TContext extends object = object,\n  TLayer extends object = object,\n> = Readonly<{\n  create: (context: ServicesContext<TConfig, TServices, TContext>) => TLayer\n}>\ntype FeaturesContext<\n  TConfig extends Config = Config,\n  TServices extends object = object,\n  TFeatures extends object = object,\n  TGlobals extends object = object,\n> = LayerContext<\n  TConfig,\n  { services: TServices; features: TFeatures } & TGlobals\n>\ntype FeaturesLayerFactory<\n  TConfig extends Config = Config,\n  TContext extends object = object,\n  TServices extends object = object,\n  TFeatures extends object = object,\n  TLayer extends object = object,\n> = Readonly<{\n  create: (\n    context: FeaturesContext<TConfig, TServices, TFeatures, TContext>\n  ) => TLayer\n}>\ntype System<\n  TConfig extends Config = Config,\n  TServices extends object = object,\n  TFeatures extends object = object,\n> = CommonContext<TConfig> & { services: TServices; features: TFeatures }\n\n// --- Models and CRUD ---\ntype ModelConstructor = Readonly<{\n  create: <\n    T extends DataDescription,\n    TModelExtensions extends object = object,\n    TModelInstanceExtensions extends object = object,\n  >(\n    modelProps: ModelProps\n  ) => ModelType<T, TModelExtensions, TModelInstanceExtensions>\n}>\ntype ModelProps<\n  TModelOverrides extends object = object,\n  TModelInstanceOverrides extends object = object,\n> = Readonly<{\n  Model: ModelFactory<TModelOverrides, TModelOverrides>\n  fetcher: ModelInstanceFetcher<TModelOverrides, TModelInstanceOverrides>\n  getModel: <T extends DataDescription>(\n    namespace: string,\n    modelName: string\n  ) => () => ModelType<T, TModelOverrides, TModelInstanceOverrides>\n}>\ntype PartialModelProps<\n  TModelOverrides extends object = object,\n  TModelInstanceOverrides extends object = object,\n> = Readonly<{\n  Model: ModelFactory<TModelOverrides, TModelOverrides>\n  fetcher: ModelInstanceFetcher<TModelOverrides, TModelInstanceOverrides>\n}>\ntype GetModelPropsFunc = (\n  context: ServicesContext,\n  ...args: any[]\n) => PartialModelProps\ntype GenericLayer = Record<string, any>\ntype LayerServices = Readonly<{\n  getModelProps: (context: ServicesContext) => ModelProps\n  loadLayer: (\n    app: App,\n    layer: string,\n    existingLayers: LayerContext\n  ) => MaybePromise<GenericLayer | undefined>\n}>\ntype LayerServicesLayer = {\n  log: LayerLogger\n  services: { [CoreNamespace.layers]: LayerServices }\n}\ntype LayerDescription = string | readonly string[]\ntype ModelToModelFactoryNamespace = Record<string, string | [string, any[]]>\ntype NamespaceToFactory = Record<string, ModelToModelFactoryNamespace>\n\n// --- Error and Utility ---\ntype ErrorObject = Readonly<{\n  error: Readonly<{\n    code: string\n    message: string\n    details?: string\n    data?: Record<string, JsonAble>\n    trace?: string\n    cause?: ErrorObject\n  }>\n}>\ntype MaybePromise<T> = Promise<T> | T\n\n// --- Model CRUDs (from models/types.ts) ---\ntype ModelCrudsFunctions<\n  TData extends DataDescription,\n  TModelExtensions extends object = object,\n  TModelInstanceExtensions extends object = object,\n> = Readonly<{\n  getModel: () => OrmModel<TData, TModelExtensions, TModelInstanceExtensions>\n  create: CreateFunction<TData>\n  retrieve: RetrieveFunction<TData>\n  update: UpdateFunction<TData>\n  delete: DeleteFunction\n  search: SearchFunction<TData>\n}>\ntype ModelServices = Readonly<{\n  createModelCruds: <TData extends DataDescription>(\n    model: OrmModel<TData>,\n    options?: CrudsOptions<TData>\n  ) => ModelCrudsFunctions<TData>\n}>\ntype CreateFunction<TData extends DataDescription> = <\n  IgnoreProperties extends string = '',\n>(\n  data: Omit<TData, IgnoreProperties> | ToObjectResult<TData>\n) => Promise<OrmModelInstance<TData>>\ntype RetrieveFunction<TData extends DataDescription> = (\n  primaryKey: PrimaryKeyType\n) => Promise<OrmModelInstance<TData> | undefined>\ntype UpdateFunction<TData extends DataDescription> = (\n  primaryKey: PrimaryKeyType,\n  data: TData | ToObjectResult<TData>\n) => Promise<OrmModelInstance<TData>>\ntype DeleteFunction = (primaryKey: PrimaryKeyType) => Promise<void>\ntype SearchFunction<TData extends DataDescription> = (\n  ormSearch: OrmSearch\n) => Promise<OrmSearchResult<TData>>\ntype CrudsOverrides<TData extends DataDescription> = Partial<\n  Omit<ModelCrudsFunctions<TData>, 'getModel'>\n>\ntype CrudsOptions<TData extends DataDescription> = Readonly<{\n  overrides?: CrudsOverrides<TData>\n}>\ntype ModelCrudsServicesContext<\n  TModels extends Record<string, ModelCrudsFunctions<any>>,\n  TConfig extends Config = Config,\n  TServices extends object = object,\n  TContext extends object = object,\n> = ServicesContext<TConfig, TServices & { cruds: TModels }, TContext>\n```\n",
    "tags": [
      "types",
      "architecture",
      "models",
      "config",
      "domains"
    ]
  },
  {
    "id": "9f70590a-3ed8-445a-a483-e2c04a93a642",
    "name": "API Surface of @node-in-layers/core",
    "description": "All functions and objects exported from @node-in-layers/core. Each export shows its name, input/output types, and a minimal code snippet. Implementation details are omitted.\n",
    "content": "```typescript\n// From index.ts\nexport { loadSystem } from './entries.js'\nexport * from './types.js'\nexport * from './models/types.js'\nexport * from './globals/logging.js'\n\n// --- Main Function ---\n// entries.ts\nasync function loadSystem<TConfig extends Config = Config>(args: {\n  environment: string\n  config?: TConfig\n}): Promise<any>\n\n// --- Logging (globals/logging.ts) ---\nfunction standardLogger<TConfig extends Config = Config>(): RootLogger<TConfig>\nfunction compositeLogger<TConfig extends Config = Config>(\n  logMethods: readonly LogMethod<TConfig>[]\n): RootLogger<TConfig>\nfunction consoleLogSimple(logMessage: LogMessage): void\nfunction consoleLogJson(logMessage: LogMessage): void\nfunction consoleLogFull(logMessage: LogMessage): void\nfunction logTcp(\n  context: CommonContext\n): (logMessage: LogMessage) => Promise<any>\n\n// --- Types and Model CRUDs (see types entry for full list) ---\n// All types from types.ts and models/types.ts are exported\n```\n",
    "tags": [
      "api-surface",
      "architecture",
      "best-practices"
    ]
  },
  {
    "id": "c1c4f0c9-annotated-functions-zod4",
    "name": "Build Features the Right Way (Annotated Functions, Zod 4 — Highly Encouraged)",
    "description": "Highly encouraged: build feature functions with annotatedFunction and Zod 4 for type-safe args/returns, cross-layer tracing, and consistent surfaces for OpenAPI/MCP.",
    "content": "### Build Features the Right Way (Annotated Functions, Zod 4 — Highly Encouraged)\n\nIt’s highly encouraged that feature-level functions use `annotatedFunction` with Zod 4. This provides:\n- Typed args/returns with runtime validation (Zod 4)\n- Cross-layer tracing via the final optional `crossLayerProps`\n- Consistent, discoverable function metadata for documentation and MCP tools\n\n```typescript\nimport { annotatedFunction, FeaturesContext, Config } from '@node-in-layers/core'\nimport { z } from 'zod' // Zod v4\n\nexport const create = (context: FeaturesContext<Config, any>) => {\n  const hello = annotatedFunction(\n    {\n      functionName: 'hello',\n      domain: 'greetings',\n      description: 'Greets a user by name.',\n      args: z.object({ name: z.string() }),\n      returns: z.object({ greeting: z.string() }),\n    },\n    (args, crossLayerProps) => {\n      const log = context.log.getInnerLogger('hello', crossLayerProps)\n      log.info('Greeting user', { name: args.name })\n      return { greeting: `Hello ${args.name}` }\n    }\n  )\n\n  return { hello }\n}\n```\n\n> Use Zod 4 explicitly. Using `annotatedFunction` is highly encouraged for building features the right way.",
    "tags": [
      "features",
      "zod4",
      "annotatedFunction",
      "best-practices",
      "mcp"
    ]
  }
]